<H2>**ORM**</H2>

- Application과 RDB의 테이블을 매핑한다는 뜻이며,
기술적으로는 어플리케이션 객체를 RDB 테이블에 자동으로 영속화 해주는 것이라고 볼 수 있다.

**[특징]**
>SQL문이 아닌 메소드를 통해 DB를 조작한다.
>
>객체 지향적인 코드작성이 가능하다.
>
>매핑정보가 Class로 명시되어있기 때문에 ERD를 보는 의존도를 낮출 수 있고, 유지보수와 리팩토링에 유리하다.
>
>하지만 복잡하거나 무거운 쿼리는 결국 SQL문을 써야할 수도 있다.


---
<H2>**JPA**</H2>

- JAVA 에서 ORM 기술 표준으로 사용하는 인터페이스 모음
- 자바 어플리케이션에서 관계형 DB를 사용하는 방식을 정의한 인터페이스

**[특징]**
> Hibernate, OpenJPA 등이 구현함 (Hibernate : ORM의 프레임워크, open source SW)
>
> 객체와 관계형 데이터 베이스의 데이터를 매핑하는 기술
>
>JPA는 애플리케이션과 JDBC 사이에서 동작하며, JDBC API를 사용하여 데이터베이스와 데이터를 주고받게 된다.
>
>이 과정에서 객체와 테이블을 매핑하여 패러다임 불일치 문제를 해결한다.
>
>결과적으로 생산성 향상, 유지보수의 편리, 불일치 문제가 해결됨으로써 SQL 작성시 발생하는 많은 불편함들을 해결할 수 있다.
---
<H3>**JPA 동작 과정**</H3>

JPA는 JAVA 애플리케이션과 JDBC에서 동작한다. 

JAVA 애플리케이션에서 JPA를 사용하면 내부에서 JDBC API를 사용하여 SQL를 DB에 전달하고 결과를 반환받는다.


<H3>**객체 매핑**</H3> 

JPA 에서 Entity란, DB테이블에 대응하는 하나의 클래스이다.

@Entity 가 붙은 클래스를 JPA가 각 필드의 어노테이션을 보고 DB테이블과 매핑해 관리 해준다.



---


<H2>QueryDSL</H2>
>Hibernate Query Language를 타입에 안전한 방식으로 실행하기 위한 목적으로 만들어졌다. 
>
>기존 쿼리는 가독성도 떨어지고, 안전성이 보장되지 않았다.  
>
>이를 도메인 모델로 변경하여 직접 쿼리에 반영시키고, 오류 여부를 컴파일 단계에서 알 수 있도록 하는 것이 QueryDSL이다. 

>또한, JPA에서 사용되는 JPQL 보다 가독성도 좋다. 
>
>내부적으로는 JPQL을 사용하기 때문에 동일한 동작을 하며, JPQL과 동일하게 영속성 컨텍스트에 이미 동일한 값이 있다면, DB에서 가져온 값을 버리고 영속성 컨텍스트에 있는 값을 사용한다. 
>
>이외에도 Criteria, Native Query 가 있지만, 코드 가독성, 동적 쿼리 생성의 펀리성 등에서 QueryDSL이 가장 접근하기 쉽고 편하다.



---

<H3>Comment</H3>

**Spring Data JPA + QueryDSL** 로 실무에서 사용하면서, 이론적으로 한번 정리해 보고 싶었다. 

기존에 MySQL 의 쿼리문을 리팩토링 하면서 가독성이나 디버깅의 편리함을 경험하고 있다.  

